[
  {
    "objectID": "202602/bringing-memory-to-claude-code.html",
    "href": "202602/bringing-memory-to-claude-code.html",
    "title": "Bringing Memory to Claude Code: Lessons from OpenClaw",
    "section": "",
    "text": "I’ve been spending a lot of time with Claude Code lately, and recently came across OpenClaw — an open-source AI agent platform. What caught my attention was its memory system: a clean, three-part design that lets the agent remember things across sessions and survive context compaction. I decided to dig into the source code, understand how it works, and see if I could bring the same idea to Claude Code using its hook system.\nThis isn’t a production-ready solution or a recommendation for everyone. It’s a learning exercise — studying a well-designed system and experimenting with applying it somewhere else.\n\n\nOpenClaw’s memory system has three distinct parts: recall (reading memories), flush (saving before compaction), and session save (capturing session context). Each serves a different purpose, and together they form a complete memory lifecycle.\nflowchart TD\n    subgraph Write\n        A[Conversation in progress] --&gt;|Context near limit| B[Memory Flush]\n        B --&gt;|Agent extracts durable memories| D[(memory/YYYY-MM-DD.md)]\n        A --&gt;|User runs /new| C[Session Memory]\n        C --&gt;|Dump last N messages| D\n    end\n\n    subgraph Read\n        E[New session / question] --&gt;|Before answering| F[memory_search]\n        F --&gt;|Semantic search via qmd| D\n        F --&gt;|Top results with path + lines| G[memory_get]\n        G --&gt;|Pull specific snippets| H[Response with citations]\n    end\n\n\nThe recall side is built into OpenClaw’s system prompt. When memory_search and memory_get tools are available, the agent is instructed to search memory files before answering anything about prior work, decisions, dates, people, preferences, or todos:\nBefore answering anything about prior work, decisions, dates, people,\npreferences, or todos: run memory_search on MEMORY.md + memory/*.md;\nthen use memory_get to pull only the needed lines.\nIf low confidence after search, say you checked.\nmemory_search performs semantic search across MEMORY.md and memory/*.md files. Under the hood, it uses qmd — an on-device search engine that combines BM25 full-text search, vector semantic search, and LLM re-ranking. All processing happens locally with GGUF models, no cloud dependency.\nmemory_get is a simple snippet reader. After memory_search returns matching results with file paths and line numbers, memory_get pulls the specific lines needed — keeping the context small and precise.\n\n\n\nWhen a conversation grows long enough to approach the context window limit, OpenClaw triggers a memory flush before compaction happens. The implementation in memory-flush.ts checks whether totalTokens &gt;= contextWindow - reserveTokens - softThreshold (with a default soft threshold of 4000 tokens). When that condition is met, the agent receives a prompt:\nPre-compaction memory flush.\nStore durable memories now (use memory/YYYY-MM-DD.md; create memory/ if needed).\nIf nothing to store, reply with NO_REPLY.\nThis is the intelligent part — the agent analyzes the conversation and decides what’s worth keeping. It’s not a blind dump; the agent extracts decisions, preferences, important context, and writes structured notes to date-stamped markdown files.\n\n\n\nThe session memory hook fires when the user issues the /new command to start a fresh session. Unlike the memory flush, this is deliberately simple:\n\nExtract the last N messages from the previous session (default: 15)\nUse an LLM to generate a short filename slug (e.g., “vendor-pitch”, “api-design”)\nSave the transcript to memory/YYYY-MM-DD-slug.md\n\nNo analysis, no summarization — just a raw transcript dump. The idea is that the raw conversation itself is valuable context for future sessions, and the semantic search on the recall side will find the relevant parts when needed.\n\n\n\n\nWith a clear picture of OpenClaw’s design, the next question is: can we replicate this in Claude Code? The answer is yes, using Claude Code’s hook system.\nClaude Code hooks are shell commands that execute automatically at specific points in a session’s lifecycle. The two events we need are PreCompact (fires before context compaction) and SessionEnd (fires when a session terminates). Both accept command hooks — shell scripts that receive JSON context via stdin.\n\n\nHere’s how OpenClaw’s three-part memory maps to Claude Code:\n\n\n\n\n\n\n\n\nOpenClaw\nClaude Code\nMechanism\n\n\n\n\nMemory Flush (pre-compaction)\nPreCompact hook\nShell script, uses claude -p for extraction\n\n\nSession Memory (/new command)\nSessionEnd hook\nShell script, uses claude -p for slug generation\n\n\nMemory Recall (memory_search)\nqmd MCP server\nMCP integration\n\n\n\nStorage: Memory files are stored at ~/.cc-memory/[project-path]/memory/, where [project-path] is the project’s absolute path converted to a valid folder name (e.g., /Users/me/my-project becomes Users__me__my-project). This keeps memories separated per project while stored in a global location.\nThe choice of PreCompact for memory flush is a direct parallel — both fire right before context compaction. SessionEnd replaces OpenClaw’s /new hook since Claude Code fires it when a session terminates (user exit, /clear, logout). For recall, qmd already provides an MCP server, so Claude Code can use it directly as an MCP tool.\nBoth scripts use claude -p (Claude Code’s pipe mode) for LLM capabilities. This means no API keys to configure, no SDK dependencies — just the claude CLI that’s already installed.\n\n\n\n\n\n\nBoth hooks are configured in ~/.claude/settings.json to apply globally across all projects:\n{\n  \"hooks\": {\n    \"PreCompact\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"$HOME/.cc-memory/scripts/memory-flush.sh\\\"\",\n            \"timeout\": 120\n          }\n        ]\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"$HOME/.cc-memory/scripts/save-session.sh\\\"\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ]\n  }\n}\n\n\n\nThe memory flush script reads the conversation transcript, pipes it to claude -p for intelligent extraction, and writes the result to a memory file:\n#!/bin/bash\n# memory-flush.sh - PreCompact hook\n\nset -euo pipefail\n\n# Guard against recursive invocation (claude -p triggers hooks too)\nif [ \"${CC_MEMORY_HOOK:-}\" = \"1\" ]; then\n  exit 0\nfi\n\nINPUT=$(cat)\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd')\n\n# Convert project path to folder name (strip leading /, replace / with __)\nPROJECT_FOLDER=$(echo \"$CWD\" | sed 's|^/||' | sed 's|/|__|g')\nMEMORY_DIR=\"$HOME/.cc-memory/$PROJECT_FOLDER/memory\"\nmkdir -p \"$MEMORY_DIR\"\n\nDATE=$(date +%Y-%m-%d)\nFILENAME=\"$MEMORY_DIR/$DATE.md\"\n\nif [ ! -f \"$TRANSCRIPT_PATH\" ]; then\n  exit 0\nfi\n\n# Read the last ~50KB of the transcript to stay within token limits\nTRANSCRIPT_CONTENT=$(tail -c 50000 \"$TRANSCRIPT_PATH\")\n\nMEMORY_CONTENT=$(echo \"$TRANSCRIPT_CONTENT\" | CC_MEMORY_HOOK=1 claude -p \\\n  \"You are a memory extraction agent. The following is a conversation\ntranscript (JSONL format) from a coding session. Extract durable memories\nthat should be preserved:\n\n- Decisions made\n- User preferences discovered\n- Important technical context\n- Todos and action items\n- Key outcomes and conclusions\n\nFormat the output as markdown with clear sections and bullet points.\nBe concise but capture everything important.\nIf there is nothing worth saving, respond with exactly NO_REPLY.\")\n\nif [ -z \"$MEMORY_CONTENT\" ] || [ \"$MEMORY_CONTENT\" = \"NO_REPLY\" ]; then\n  exit 0\nfi\n\n# Append separator if file already exists\nif [ -f \"$FILENAME\" ]; then\n  echo \"\" &gt;&gt; \"$FILENAME\"\n  echo \"---\" &gt;&gt; \"$FILENAME\"\n  echo \"\" &gt;&gt; \"$FILENAME\"\nfi\n\necho \"## Memory Flush - $(date -u '+%H:%M UTC')\" &gt;&gt; \"$FILENAME\"\necho \"\" &gt;&gt; \"$FILENAME\"\necho \"$MEMORY_CONTENT\" &gt;&gt; \"$FILENAME\"\n\nexit 0\nA few things to note: - The CC_MEMORY_HOOK=1 prefix sets an environment variable for the claude -p subprocess. Both scripts check this variable at entry and exit early if set — this prevents recursive invocation, since claude -p itself triggers SessionEnd hooks when it finishes. - It reads the last 50KB of the transcript rather than the whole file, to keep the input manageable. - Multiple compactions in the same day append to the same file with --- separators.\n\n\n\nThe session save script dumps the last 15 transcript entries to a file, using claude -p to generate a descriptive filename slug — matching OpenClaw’s approach:\n#!/bin/bash\n# save-session.sh - SessionEnd hook\n\nset -euo pipefail\n\n# Guard against recursive invocation (claude -p triggers hooks too)\nif [ \"${CC_MEMORY_HOOK:-}\" = \"1\" ]; then\n  exit 0\nfi\n\nINPUT=$(cat)\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd')\n\n# Convert project path to folder name (strip leading /, replace / with __)\nPROJECT_FOLDER=$(echo \"$CWD\" | sed 's|^/||' | sed 's|/|__|g')\nMEMORY_DIR=\"$HOME/.cc-memory/$PROJECT_FOLDER/memory\"\nmkdir -p \"$MEMORY_DIR\"\n\nDATE=$(date +%Y-%m-%d)\n\nif [ ! -f \"$TRANSCRIPT_PATH\" ]; then\n  exit 0\nfi\n\n# Extract last 15 entries from transcript JSONL\nSESSION_CONTENT=$(tail -n 15 \"$TRANSCRIPT_PATH\")\n\n# Generate slug via claude -p (first 2000 chars to keep it fast)\nSLUG=$(echo \"$SESSION_CONTENT\" | head -c 2000 | CC_MEMORY_HOOK=1 claude -p \\\n  \"Based on this conversation transcript, generate a short 1-2 word\nfilename slug (lowercase, hyphen-separated, no file extension).\nReply with ONLY the slug, nothing else.\nExamples: vendor-pitch, api-design, bug-fix\")\n\n# Sanitize slug: lowercase, only alphanumeric and hyphens, max 30 chars\nSLUG=$(echo \"$SLUG\" | tr '[:upper:]' '[:lower:]' \\\n  | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' \\\n  | sed 's/^-//' | sed 's/-$//' | head -c 30)\n\n# Fallback to timestamp if slug generation fails\nif [ -z \"$SLUG\" ]; then\n  SLUG=$(date +%H%M)\nfi\n\nFILENAME=\"$MEMORY_DIR/$DATE-$SLUG.md\"\n\necho \"# Session: $(date -u '+%Y-%m-%d %H:%M:%S UTC')\" &gt; \"$FILENAME\"\necho \"- **Project**: $CWD\" &gt;&gt; \"$FILENAME\"\necho \"\" &gt;&gt; \"$FILENAME\"\necho \"$SESSION_CONTENT\" &gt;&gt; \"$FILENAME\"\n\nexit 0\nThe only LLM usage here is for the filename slug — the transcript content itself is saved as-is. The semantic search on the recall side handles finding relevant content later.\n\n\n\nFor the recall side, qmd provides an MCP server out of the box. The setup involves:\n\nCreate a collection for each project’s memory directory:\n\nqmd collection create my-project ~/.cc-memory/my_project/memory \\\n  --context \"Development memories and session history for my-project\"\n\nConfigure Claude Code to use qmd as an MCP server. In .claude/settings.json or ~/.claude/settings.json:\n\n{\n  \"mcpServers\": {\n    \"qmd\": {\n      \"command\": \"qmd\",\n      \"args\": [\"mcp\"]\n    }\n  }\n}\n\nGuide recall behavior via CLAUDE.md. Add instructions similar to OpenClaw’s system prompt:\n\n## Memory\n\nBefore answering questions about prior work, decisions, or preferences,\nsearch the memory collection using the qmd MCP tools. Use the search\nresults to inform your response.\nOnce configured, Claude Code can use qmd’s MCP tools — semantic search, deep search with reranking, and document retrieval — to query the memory files. This completes the memory lifecycle: PreCompact and SessionEnd write memories, qmd reads them back.\n\n\n\n\nStudying OpenClaw’s memory system was a rewarding exercise. The three-part design — recall, flush, and session save — is elegant in how each part has a clear responsibility and minimal complexity. The memory flush is smart (LLM-driven analysis), the session save is dumb (raw transcript dump with an LLM-generated slug), and the recall leverages semantic search to find needles in haystacks.\nThe mapping to Claude Code turned out to be straightforward. PreCompact and SessionEnd fire at exactly the right moments, claude -p gives hook scripts access to LLM capabilities without any extra setup, and qmd — the same tool OpenClaw uses internally for memory_search — provides the recall side via MCP.\nWhat I took away from this is that Claude Code’s hook system, combined with MCP, makes it surprisingly extensible. These hooks weren’t designed for memory, but they provide the right building blocks. If you’re interested in extending Claude Code beyond its defaults, the hook system is worth a look."
  },
  {
    "objectID": "202602/bringing-memory-to-claude-code.html#how-openclaw-handles-memory",
    "href": "202602/bringing-memory-to-claude-code.html#how-openclaw-handles-memory",
    "title": "Bringing Memory to Claude Code: Lessons from OpenClaw",
    "section": "",
    "text": "OpenClaw’s memory system has three distinct parts: recall (reading memories), flush (saving before compaction), and session save (capturing session context). Each serves a different purpose, and together they form a complete memory lifecycle.\nflowchart TD\n    subgraph Write\n        A[Conversation in progress] --&gt;|Context near limit| B[Memory Flush]\n        B --&gt;|Agent extracts durable memories| D[(memory/YYYY-MM-DD.md)]\n        A --&gt;|User runs /new| C[Session Memory]\n        C --&gt;|Dump last N messages| D\n    end\n\n    subgraph Read\n        E[New session / question] --&gt;|Before answering| F[memory_search]\n        F --&gt;|Semantic search via qmd| D\n        F --&gt;|Top results with path + lines| G[memory_get]\n        G --&gt;|Pull specific snippets| H[Response with citations]\n    end\n\n\nThe recall side is built into OpenClaw’s system prompt. When memory_search and memory_get tools are available, the agent is instructed to search memory files before answering anything about prior work, decisions, dates, people, preferences, or todos:\nBefore answering anything about prior work, decisions, dates, people,\npreferences, or todos: run memory_search on MEMORY.md + memory/*.md;\nthen use memory_get to pull only the needed lines.\nIf low confidence after search, say you checked.\nmemory_search performs semantic search across MEMORY.md and memory/*.md files. Under the hood, it uses qmd — an on-device search engine that combines BM25 full-text search, vector semantic search, and LLM re-ranking. All processing happens locally with GGUF models, no cloud dependency.\nmemory_get is a simple snippet reader. After memory_search returns matching results with file paths and line numbers, memory_get pulls the specific lines needed — keeping the context small and precise.\n\n\n\nWhen a conversation grows long enough to approach the context window limit, OpenClaw triggers a memory flush before compaction happens. The implementation in memory-flush.ts checks whether totalTokens &gt;= contextWindow - reserveTokens - softThreshold (with a default soft threshold of 4000 tokens). When that condition is met, the agent receives a prompt:\nPre-compaction memory flush.\nStore durable memories now (use memory/YYYY-MM-DD.md; create memory/ if needed).\nIf nothing to store, reply with NO_REPLY.\nThis is the intelligent part — the agent analyzes the conversation and decides what’s worth keeping. It’s not a blind dump; the agent extracts decisions, preferences, important context, and writes structured notes to date-stamped markdown files.\n\n\n\nThe session memory hook fires when the user issues the /new command to start a fresh session. Unlike the memory flush, this is deliberately simple:\n\nExtract the last N messages from the previous session (default: 15)\nUse an LLM to generate a short filename slug (e.g., “vendor-pitch”, “api-design”)\nSave the transcript to memory/YYYY-MM-DD-slug.md\n\nNo analysis, no summarization — just a raw transcript dump. The idea is that the raw conversation itself is valuable context for future sessions, and the semantic search on the recall side will find the relevant parts when needed."
  },
  {
    "objectID": "202602/bringing-memory-to-claude-code.html#mapping-to-claude-code",
    "href": "202602/bringing-memory-to-claude-code.html#mapping-to-claude-code",
    "title": "Bringing Memory to Claude Code: Lessons from OpenClaw",
    "section": "",
    "text": "With a clear picture of OpenClaw’s design, the next question is: can we replicate this in Claude Code? The answer is yes, using Claude Code’s hook system.\nClaude Code hooks are shell commands that execute automatically at specific points in a session’s lifecycle. The two events we need are PreCompact (fires before context compaction) and SessionEnd (fires when a session terminates). Both accept command hooks — shell scripts that receive JSON context via stdin.\n\n\nHere’s how OpenClaw’s three-part memory maps to Claude Code:\n\n\n\n\n\n\n\n\nOpenClaw\nClaude Code\nMechanism\n\n\n\n\nMemory Flush (pre-compaction)\nPreCompact hook\nShell script, uses claude -p for extraction\n\n\nSession Memory (/new command)\nSessionEnd hook\nShell script, uses claude -p for slug generation\n\n\nMemory Recall (memory_search)\nqmd MCP server\nMCP integration\n\n\n\nStorage: Memory files are stored at ~/.cc-memory/[project-path]/memory/, where [project-path] is the project’s absolute path converted to a valid folder name (e.g., /Users/me/my-project becomes Users__me__my-project). This keeps memories separated per project while stored in a global location.\nThe choice of PreCompact for memory flush is a direct parallel — both fire right before context compaction. SessionEnd replaces OpenClaw’s /new hook since Claude Code fires it when a session terminates (user exit, /clear, logout). For recall, qmd already provides an MCP server, so Claude Code can use it directly as an MCP tool.\nBoth scripts use claude -p (Claude Code’s pipe mode) for LLM capabilities. This means no API keys to configure, no SDK dependencies — just the claude CLI that’s already installed."
  },
  {
    "objectID": "202602/bringing-memory-to-claude-code.html#implementation",
    "href": "202602/bringing-memory-to-claude-code.html#implementation",
    "title": "Bringing Memory to Claude Code: Lessons from OpenClaw",
    "section": "",
    "text": "Both hooks are configured in ~/.claude/settings.json to apply globally across all projects:\n{\n  \"hooks\": {\n    \"PreCompact\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"$HOME/.cc-memory/scripts/memory-flush.sh\\\"\",\n            \"timeout\": 120\n          }\n        ]\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"$HOME/.cc-memory/scripts/save-session.sh\\\"\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ]\n  }\n}\n\n\n\nThe memory flush script reads the conversation transcript, pipes it to claude -p for intelligent extraction, and writes the result to a memory file:\n#!/bin/bash\n# memory-flush.sh - PreCompact hook\n\nset -euo pipefail\n\n# Guard against recursive invocation (claude -p triggers hooks too)\nif [ \"${CC_MEMORY_HOOK:-}\" = \"1\" ]; then\n  exit 0\nfi\n\nINPUT=$(cat)\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd')\n\n# Convert project path to folder name (strip leading /, replace / with __)\nPROJECT_FOLDER=$(echo \"$CWD\" | sed 's|^/||' | sed 's|/|__|g')\nMEMORY_DIR=\"$HOME/.cc-memory/$PROJECT_FOLDER/memory\"\nmkdir -p \"$MEMORY_DIR\"\n\nDATE=$(date +%Y-%m-%d)\nFILENAME=\"$MEMORY_DIR/$DATE.md\"\n\nif [ ! -f \"$TRANSCRIPT_PATH\" ]; then\n  exit 0\nfi\n\n# Read the last ~50KB of the transcript to stay within token limits\nTRANSCRIPT_CONTENT=$(tail -c 50000 \"$TRANSCRIPT_PATH\")\n\nMEMORY_CONTENT=$(echo \"$TRANSCRIPT_CONTENT\" | CC_MEMORY_HOOK=1 claude -p \\\n  \"You are a memory extraction agent. The following is a conversation\ntranscript (JSONL format) from a coding session. Extract durable memories\nthat should be preserved:\n\n- Decisions made\n- User preferences discovered\n- Important technical context\n- Todos and action items\n- Key outcomes and conclusions\n\nFormat the output as markdown with clear sections and bullet points.\nBe concise but capture everything important.\nIf there is nothing worth saving, respond with exactly NO_REPLY.\")\n\nif [ -z \"$MEMORY_CONTENT\" ] || [ \"$MEMORY_CONTENT\" = \"NO_REPLY\" ]; then\n  exit 0\nfi\n\n# Append separator if file already exists\nif [ -f \"$FILENAME\" ]; then\n  echo \"\" &gt;&gt; \"$FILENAME\"\n  echo \"---\" &gt;&gt; \"$FILENAME\"\n  echo \"\" &gt;&gt; \"$FILENAME\"\nfi\n\necho \"## Memory Flush - $(date -u '+%H:%M UTC')\" &gt;&gt; \"$FILENAME\"\necho \"\" &gt;&gt; \"$FILENAME\"\necho \"$MEMORY_CONTENT\" &gt;&gt; \"$FILENAME\"\n\nexit 0\nA few things to note: - The CC_MEMORY_HOOK=1 prefix sets an environment variable for the claude -p subprocess. Both scripts check this variable at entry and exit early if set — this prevents recursive invocation, since claude -p itself triggers SessionEnd hooks when it finishes. - It reads the last 50KB of the transcript rather than the whole file, to keep the input manageable. - Multiple compactions in the same day append to the same file with --- separators.\n\n\n\nThe session save script dumps the last 15 transcript entries to a file, using claude -p to generate a descriptive filename slug — matching OpenClaw’s approach:\n#!/bin/bash\n# save-session.sh - SessionEnd hook\n\nset -euo pipefail\n\n# Guard against recursive invocation (claude -p triggers hooks too)\nif [ \"${CC_MEMORY_HOOK:-}\" = \"1\" ]; then\n  exit 0\nfi\n\nINPUT=$(cat)\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd')\n\n# Convert project path to folder name (strip leading /, replace / with __)\nPROJECT_FOLDER=$(echo \"$CWD\" | sed 's|^/||' | sed 's|/|__|g')\nMEMORY_DIR=\"$HOME/.cc-memory/$PROJECT_FOLDER/memory\"\nmkdir -p \"$MEMORY_DIR\"\n\nDATE=$(date +%Y-%m-%d)\n\nif [ ! -f \"$TRANSCRIPT_PATH\" ]; then\n  exit 0\nfi\n\n# Extract last 15 entries from transcript JSONL\nSESSION_CONTENT=$(tail -n 15 \"$TRANSCRIPT_PATH\")\n\n# Generate slug via claude -p (first 2000 chars to keep it fast)\nSLUG=$(echo \"$SESSION_CONTENT\" | head -c 2000 | CC_MEMORY_HOOK=1 claude -p \\\n  \"Based on this conversation transcript, generate a short 1-2 word\nfilename slug (lowercase, hyphen-separated, no file extension).\nReply with ONLY the slug, nothing else.\nExamples: vendor-pitch, api-design, bug-fix\")\n\n# Sanitize slug: lowercase, only alphanumeric and hyphens, max 30 chars\nSLUG=$(echo \"$SLUG\" | tr '[:upper:]' '[:lower:]' \\\n  | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' \\\n  | sed 's/^-//' | sed 's/-$//' | head -c 30)\n\n# Fallback to timestamp if slug generation fails\nif [ -z \"$SLUG\" ]; then\n  SLUG=$(date +%H%M)\nfi\n\nFILENAME=\"$MEMORY_DIR/$DATE-$SLUG.md\"\n\necho \"# Session: $(date -u '+%Y-%m-%d %H:%M:%S UTC')\" &gt; \"$FILENAME\"\necho \"- **Project**: $CWD\" &gt;&gt; \"$FILENAME\"\necho \"\" &gt;&gt; \"$FILENAME\"\necho \"$SESSION_CONTENT\" &gt;&gt; \"$FILENAME\"\n\nexit 0\nThe only LLM usage here is for the filename slug — the transcript content itself is saved as-is. The semantic search on the recall side handles finding relevant content later.\n\n\n\nFor the recall side, qmd provides an MCP server out of the box. The setup involves:\n\nCreate a collection for each project’s memory directory:\n\nqmd collection create my-project ~/.cc-memory/my_project/memory \\\n  --context \"Development memories and session history for my-project\"\n\nConfigure Claude Code to use qmd as an MCP server. In .claude/settings.json or ~/.claude/settings.json:\n\n{\n  \"mcpServers\": {\n    \"qmd\": {\n      \"command\": \"qmd\",\n      \"args\": [\"mcp\"]\n    }\n  }\n}\n\nGuide recall behavior via CLAUDE.md. Add instructions similar to OpenClaw’s system prompt:\n\n## Memory\n\nBefore answering questions about prior work, decisions, or preferences,\nsearch the memory collection using the qmd MCP tools. Use the search\nresults to inform your response.\nOnce configured, Claude Code can use qmd’s MCP tools — semantic search, deep search with reranking, and document retrieval — to query the memory files. This completes the memory lifecycle: PreCompact and SessionEnd write memories, qmd reads them back."
  },
  {
    "objectID": "202602/bringing-memory-to-claude-code.html#conclusion",
    "href": "202602/bringing-memory-to-claude-code.html#conclusion",
    "title": "Bringing Memory to Claude Code: Lessons from OpenClaw",
    "section": "",
    "text": "Studying OpenClaw’s memory system was a rewarding exercise. The three-part design — recall, flush, and session save — is elegant in how each part has a clear responsibility and minimal complexity. The memory flush is smart (LLM-driven analysis), the session save is dumb (raw transcript dump with an LLM-generated slug), and the recall leverages semantic search to find needles in haystacks.\nThe mapping to Claude Code turned out to be straightforward. PreCompact and SessionEnd fire at exactly the right moments, claude -p gives hook scripts access to LLM capabilities without any extra setup, and qmd — the same tool OpenClaw uses internally for memory_search — provides the recall side via MCP.\nWhat I took away from this is that Claude Code’s hook system, combined with MCP, makes it surprisingly extensible. These hooks weren’t designed for memory, but they provide the right building blocks. If you’re interested in extending Claude Code beyond its defaults, the hook system is worth a look."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Han’s Posts",
    "section": "",
    "text": "Bringing Memory to Claude Code: Lessons from OpenClaw\n\n\n\n\n\n\n\n\nFeb 13, 2026\n\n\n\n\n\nNo matching items"
  }
]