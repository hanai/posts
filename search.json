[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Han’s Posts",
    "section": "",
    "text": "想买一个 Mac Mini 来养小龙虾(OpenClaw)？你可以先等等\n\n\n\n\n\n\n\n\nFeb 26, 2026\n\n\n\n\n\n\n\n\n\n\n\n\nBringing Memory to Claude Code: Lessons from OpenClaw\n\n\n\n\n\n\n\n\nFeb 13, 2026\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html",
    "href": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html",
    "title": "想买一个 Mac Mini 来养小龙虾(OpenClaw)？你可以先等等",
    "section": "",
    "text": "OpenClaw 最近很火，很多人在讨论要不要专门买台 Mac Mini 来跑它。先别急， 有个更省事的方案——用 Lume 在你现有的 Mac 上跑一台 macOS 虚拟机，体验相当不错。\n在聊 Lume 之前，说说为什么其他选项不够好："
  },
  {
    "objectID": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html#什么是-lume",
    "href": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html#什么是-lume",
    "title": "想买一个 Mac Mini 来养小龙虾(OpenClaw)？你可以先等等",
    "section": "什么是 Lume",
    "text": "什么是 Lume\nLume 是一个基于 Apple 官方 Virtualization.framework 的 macOS/Linux 虚拟机管理工具，专为 Apple Silicon（M1 及以上）设计。\n几个关键特点：\n\n接近原生的性能：直接使用硬件虚拟化，不走 QEMU 等软件模拟层\nCLI 优先，没有 GUI：通过命令行或 REST API 管理，headless 场景是第一公民\n轻量：不依赖额外的 Hypervisor，本身资源占用小\n无人值守安装：--unattended 参数全自动完成 macOS 安装，不需要手动点选"
  },
  {
    "objectID": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html#安装-lume",
    "href": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html#安装-lume",
    "title": "想买一个 Mac Mini 来养小龙虾(OpenClaw)？你可以先等等",
    "section": "安装 Lume",
    "text": "安装 Lume\nbrew install lume\n硬盘空间有限的话，可以把虚拟机存到外部硬盘：\n# 添加外部存储位置\nlume config storage add external /Volumes/HS-C2000/lume\n# 设为新虚拟机的默认存储\nlume config storage default external"
  },
  {
    "objectID": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html#创建虚拟机",
    "href": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html#创建虚拟机",
    "title": "想买一个 Mac Mini 来养小龙虾(OpenClaw)？你可以先等等",
    "section": "创建虚拟机",
    "text": "创建虚拟机\n完整流程参考 Lume 官方 Quickstart 文档， 包括 ipsw 镜像的下载方式。准备好镜像后，一条命令完成安装：\nlume create vm-oc \\\n  --os macos \\\n  --ipsw /Volumes/HS-C2000/Downloads/UniversalMac_26.2_25C56_Restore.ipsw \\\n  --storage external \\\n  --unattended tahoe\n--unattended 会全自动完成系统安装，静等结束就好。"
  },
  {
    "objectID": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html#启动并连接",
    "href": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html#启动并连接",
    "title": "想买一个 Mac Mini 来养小龙虾(OpenClaw)？你可以先等等",
    "section": "启动并连接",
    "text": "启动并连接\n安装完成后，headless 模式后台启动：\nlume run vm-oc --no-display &gt; /dev/null 2&gt;&1 &\n命令执行后，系统会自动弹出「屏幕共享」连接到虚拟机，就可以像操作一台普通 Mac 一样，在里面安装 OpenClaw 了。OpenClaw 的安装直接参考 官方文档，在 VM 里没有额外的坑。"
  },
  {
    "objectID": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html#跑起来之后",
    "href": "202602/try-openclaw-with-lume-vm-before-buying-mac-mini.html#跑起来之后",
    "title": "想买一个 Mac Mini 来养小龙虾(OpenClaw)？你可以先等等",
    "section": "跑起来之后",
    "text": "跑起来之后\n性能比我预期的好，OpenClaw 日常使用响应不慢。和 UTM 比，最大的差别是省心—— 不需要打开一个 GUI 程序来管虚拟机，命令行启停，干净。\n说实话，OpenClaw 还在快速迭代，现在就花几千块买台专用机器，多少有点赌。 但这个方案可以让你现在就跑起来，真的用顺手了、确认值得，再考虑买硬件不迟。"
  },
  {
    "objectID": "202602/bringing-memory-to-claude-code.html",
    "href": "202602/bringing-memory-to-claude-code.html",
    "title": "Bringing Memory to Claude Code: Lessons from OpenClaw",
    "section": "",
    "text": "I’ve been spending a lot of time with Claude Code lately, and recently came across OpenClaw — an open-source AI agent platform. What caught my attention was its memory system: a clean, three-part design that lets the agent remember things across sessions and survive context compaction. I decided to dig into the source code, understand how it works, and see if I could bring the same idea to Claude Code using its hook system.\nThis isn’t a production-ready solution or a recommendation for everyone. It’s a learning exercise — studying a well-designed system and experimenting with applying it somewhere else.\n\n\nOpenClaw’s memory system has three distinct parts: recall (reading memories), flush (saving before compaction), and session save (capturing session context). Each serves a different purpose, and together they form a complete memory lifecycle.\n\n\n\n\n\nflowchart TD\n    subgraph Write\n        A[Conversation in progress] --&gt;|Context near limit| B[Memory Flush]\n        B --&gt;|Agent extracts durable memories| D[(memory/YYYY-MM-DD.md)]\n        A --&gt;|User runs /new| C[Session Memory]\n        C --&gt;|Dump last N messages| D\n    end\n\n    subgraph Read\n        E[New session / question] --&gt;|Before answering| F[memory_search]\n        F --&gt;|Semantic search via qmd| D\n        F --&gt;|Top results with path + lines| G[memory_get]\n        G --&gt;|Pull specific snippets| H[Response with citations]\n    end\n\n\n\n\n\n\n\n\nThe recall side is built into OpenClaw’s system prompt. When memory_search and memory_get tools are available, the agent is instructed to search memory files before answering anything about prior work, decisions, dates, people, preferences, or todos:\nBefore answering anything about prior work, decisions, dates, people,\npreferences, or todos: run memory_search on MEMORY.md + memory/*.md;\nthen use memory_get to pull only the needed lines.\nIf low confidence after search, say you checked.\nmemory_search performs semantic search across MEMORY.md and memory/*.md files. Under the hood, it uses qmd — an on-device search engine that combines BM25 full-text search, vector semantic search, and LLM re-ranking. All processing happens locally with GGUF models, no cloud dependency.\nmemory_get is a simple snippet reader. After memory_search returns matching results with file paths and line numbers, memory_get pulls the specific lines needed — keeping the context small and precise.\n\n\n\nWhen a conversation grows long enough to approach the context window limit, OpenClaw triggers a memory flush before compaction happens. The implementation in memory-flush.ts checks whether totalTokens &gt;= contextWindow - reserveTokens - softThreshold (with a default soft threshold of 4000 tokens). When that condition is met, the agent receives a prompt:\nPre-compaction memory flush.\nStore durable memories now (use memory/YYYY-MM-DD.md; create memory/ if needed).\nIf nothing to store, reply with NO_REPLY.\nThis is the intelligent part — the agent analyzes the conversation and decides what’s worth keeping. It’s not a blind dump; the agent extracts decisions, preferences, important context, and writes structured notes to date-stamped markdown files.\n\n\n\nThe session memory hook fires when the user issues the /new command to start a fresh session. Unlike the memory flush, this is deliberately simple:\n\nExtract the last N messages from the previous session (default: 15)\nUse an LLM to generate a short filename slug (e.g., “vendor-pitch”, “api-design”)\nSave the transcript to memory/YYYY-MM-DD-slug.md\n\nNo analysis, no summarization — just a raw transcript dump. The idea is that the raw conversation itself is valuable context for future sessions, and the semantic search on the recall side will find the relevant parts when needed.\n\n\n\n\nWith a clear picture of OpenClaw’s design, the next question is: can we replicate this in Claude Code? The answer is yes, using Claude Code’s hook system.\nClaude Code hooks are shell commands that execute automatically at specific points in a session’s lifecycle. The two events we need are PreCompact (fires before context compaction) and SessionEnd (fires when a session terminates). Both accept command hooks — shell scripts that receive JSON context via stdin.\n\n\nHere’s how OpenClaw’s three-part memory maps to Claude Code:\n\n\n\n\n\n\n\n\nOpenClaw\nClaude Code\nMechanism\n\n\n\n\nMemory Flush (pre-compaction)\nPreCompact hook\nShell script, uses claude -p for extraction\n\n\nSession Memory (/new command)\nSessionEnd hook\nShell script, uses claude -p for slug generation\n\n\nMemory Recall (memory_search)\nqmd MCP server\nMCP integration\n\n\n\nStorage: Memory files are stored at ~/.cc-memory/[project-path]/memory/, where [project-path] is the project’s absolute path converted to a valid folder name (e.g., /Users/me/my-project becomes Users__me__my-project). This keeps memories separated per project while stored in a global location.\nThe choice of PreCompact for memory flush is a direct parallel — both fire right before context compaction. SessionEnd replaces OpenClaw’s /new hook since Claude Code fires it when a session terminates (user exit, /clear, logout). For recall, qmd already provides an MCP server, so Claude Code can use it directly as an MCP tool.\nBoth scripts use claude -p (Claude Code’s pipe mode) for LLM capabilities. This means no API keys to configure, no SDK dependencies — just the claude CLI that’s already installed.\n\n\n\n\n\n\nBoth hooks are configured in ~/.claude/settings.json to apply globally across all projects:\n{\n  \"hooks\": {\n    \"PreCompact\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"$HOME/.cc-memory/scripts/memory-flush.sh\\\"\",\n            \"timeout\": 120\n          }\n        ]\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"$HOME/.cc-memory/scripts/save-session.sh\\\"\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ]\n  }\n}\n\n\n\nThe memory flush script reads the conversation transcript, pipes it to claude -p for intelligent extraction, and writes the result to a memory file:\n#!/bin/bash\n# memory-flush.sh - PreCompact hook\n\nset -euo pipefail\n\n# Guard against recursive invocation (claude -p triggers hooks too)\nif [ \"${CC_MEMORY_HOOK:-}\" = \"1\" ]; then\n  exit 0\nfi\n\nINPUT=$(cat)\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd')\n\n# Convert project path to folder name (strip leading /, replace / with __)\nPROJECT_FOLDER=$(echo \"$CWD\" | sed 's|^/||' | sed 's|/|__|g')\nMEMORY_DIR=\"$HOME/.cc-memory/$PROJECT_FOLDER/memory\"\nmkdir -p \"$MEMORY_DIR\"\n\nDATE=$(date +%Y-%m-%d)\nFILENAME=\"$MEMORY_DIR/$DATE.md\"\n\nif [ ! -f \"$TRANSCRIPT_PATH\" ]; then\n  exit 0\nfi\n\n# Read the last ~50KB of the transcript to stay within token limits\nTRANSCRIPT_CONTENT=$(tail -c 50000 \"$TRANSCRIPT_PATH\")\n\nMEMORY_CONTENT=$(echo \"$TRANSCRIPT_CONTENT\" | CC_MEMORY_HOOK=1 claude -p \\\n  \"You are a memory extraction agent. The following is a conversation\ntranscript (JSONL format) from a coding session. Extract durable memories\nthat should be preserved:\n\n- Decisions made\n- User preferences discovered\n- Important technical context\n- Todos and action items\n- Key outcomes and conclusions\n\nFormat the output as markdown with clear sections and bullet points.\nBe concise but capture everything important.\nIf there is nothing worth saving, respond with exactly NO_REPLY.\")\n\nif [ -z \"$MEMORY_CONTENT\" ] || [ \"$MEMORY_CONTENT\" = \"NO_REPLY\" ]; then\n  exit 0\nfi\n\n# Append separator if file already exists\nif [ -f \"$FILENAME\" ]; then\n  echo \"\" &gt;&gt; \"$FILENAME\"\n  echo \"---\" &gt;&gt; \"$FILENAME\"\n  echo \"\" &gt;&gt; \"$FILENAME\"\nfi\n\necho \"## Memory Flush - $(date -u '+%H:%M UTC')\" &gt;&gt; \"$FILENAME\"\necho \"\" &gt;&gt; \"$FILENAME\"\necho \"$MEMORY_CONTENT\" &gt;&gt; \"$FILENAME\"\n\nexit 0\nA few things to note: - The CC_MEMORY_HOOK=1 prefix sets an environment variable for the claude -p subprocess. Both scripts check this variable at entry and exit early if set — this prevents recursive invocation, since claude -p itself triggers SessionEnd hooks when it finishes. - It reads the last 50KB of the transcript rather than the whole file, to keep the input manageable. - Multiple compactions in the same day append to the same file with --- separators.\n\n\n\nThe session save script dumps the last 15 transcript entries to a file, using claude -p to generate a descriptive filename slug — matching OpenClaw’s approach:\n#!/bin/bash\n# save-session.sh - SessionEnd hook\n\nset -euo pipefail\n\n# Guard against recursive invocation (claude -p triggers hooks too)\nif [ \"${CC_MEMORY_HOOK:-}\" = \"1\" ]; then\n  exit 0\nfi\n\nINPUT=$(cat)\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd')\n\n# Convert project path to folder name (strip leading /, replace / with __)\nPROJECT_FOLDER=$(echo \"$CWD\" | sed 's|^/||' | sed 's|/|__|g')\nMEMORY_DIR=\"$HOME/.cc-memory/$PROJECT_FOLDER/memory\"\nmkdir -p \"$MEMORY_DIR\"\n\nDATE=$(date +%Y-%m-%d)\n\nif [ ! -f \"$TRANSCRIPT_PATH\" ]; then\n  exit 0\nfi\n\n# Extract last 15 entries from transcript JSONL\nSESSION_CONTENT=$(tail -n 15 \"$TRANSCRIPT_PATH\")\n\n# Generate slug via claude -p (first 2000 chars to keep it fast)\nSLUG=$(echo \"$SESSION_CONTENT\" | head -c 2000 | CC_MEMORY_HOOK=1 claude -p \\\n  \"Based on this conversation transcript, generate a short 1-2 word\nfilename slug (lowercase, hyphen-separated, no file extension).\nReply with ONLY the slug, nothing else.\nExamples: vendor-pitch, api-design, bug-fix\")\n\n# Sanitize slug: lowercase, only alphanumeric and hyphens, max 30 chars\nSLUG=$(echo \"$SLUG\" | tr '[:upper:]' '[:lower:]' \\\n  | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' \\\n  | sed 's/^-//' | sed 's/-$//' | head -c 30)\n\n# Fallback to timestamp if slug generation fails\nif [ -z \"$SLUG\" ]; then\n  SLUG=$(date +%H%M)\nfi\n\nFILENAME=\"$MEMORY_DIR/$DATE-$SLUG.md\"\n\necho \"# Session: $(date -u '+%Y-%m-%d %H:%M:%S UTC')\" &gt; \"$FILENAME\"\necho \"- **Project**: $CWD\" &gt;&gt; \"$FILENAME\"\necho \"\" &gt;&gt; \"$FILENAME\"\necho \"$SESSION_CONTENT\" &gt;&gt; \"$FILENAME\"\n\nexit 0\nThe only LLM usage here is for the filename slug — the transcript content itself is saved as-is. The semantic search on the recall side handles finding relevant content later.\n\n\n\nFor the recall side, qmd provides an MCP server out of the box. The setup involves:\n\nCreate a collection for each project’s memory directory:\n\nqmd collection create my-project ~/.cc-memory/my_project/memory \\\n  --context \"Development memories and session history for my-project\"\n\nConfigure Claude Code to use qmd as an MCP server. In .claude/settings.json or ~/.claude/settings.json:\n\n{\n  \"mcpServers\": {\n    \"qmd\": {\n      \"command\": \"qmd\",\n      \"args\": [\"mcp\"]\n    }\n  }\n}\n\nGuide recall behavior via CLAUDE.md. Add instructions similar to OpenClaw’s system prompt:\n\n## Memory\n\nBefore answering questions about prior work, decisions, or preferences,\nsearch the memory collection using the qmd MCP tools. Use the search\nresults to inform your response.\nOnce configured, Claude Code can use qmd’s MCP tools — semantic search, deep search with reranking, and document retrieval — to query the memory files. This completes the memory lifecycle: PreCompact and SessionEnd write memories, qmd reads them back.\n\n\n\n\nStudying OpenClaw’s memory system was a rewarding exercise. The three-part design — recall, flush, and session save — is elegant in how each part has a clear responsibility and minimal complexity. The memory flush is smart (LLM-driven analysis), the session save is dumb (raw transcript dump with an LLM-generated slug), and the recall leverages semantic search to find needles in haystacks.\nThe mapping to Claude Code turned out to be straightforward. PreCompact and SessionEnd fire at exactly the right moments, claude -p gives hook scripts access to LLM capabilities without any extra setup, and qmd — the same tool OpenClaw uses internally for memory_search — provides the recall side via MCP.\nWhat I took away from this is that Claude Code’s hook system, combined with MCP, makes it surprisingly extensible. These hooks weren’t designed for memory, but they provide the right building blocks. If you’re interested in extending Claude Code beyond its defaults, the hook system is worth a look."
  },
  {
    "objectID": "202602/bringing-memory-to-claude-code.html#how-openclaw-handles-memory",
    "href": "202602/bringing-memory-to-claude-code.html#how-openclaw-handles-memory",
    "title": "Bringing Memory to Claude Code: Lessons from OpenClaw",
    "section": "",
    "text": "OpenClaw’s memory system has three distinct parts: recall (reading memories), flush (saving before compaction), and session save (capturing session context). Each serves a different purpose, and together they form a complete memory lifecycle.\n\n\n\n\n\nflowchart TD\n    subgraph Write\n        A[Conversation in progress] --&gt;|Context near limit| B[Memory Flush]\n        B --&gt;|Agent extracts durable memories| D[(memory/YYYY-MM-DD.md)]\n        A --&gt;|User runs /new| C[Session Memory]\n        C --&gt;|Dump last N messages| D\n    end\n\n    subgraph Read\n        E[New session / question] --&gt;|Before answering| F[memory_search]\n        F --&gt;|Semantic search via qmd| D\n        F --&gt;|Top results with path + lines| G[memory_get]\n        G --&gt;|Pull specific snippets| H[Response with citations]\n    end\n\n\n\n\n\n\n\n\nThe recall side is built into OpenClaw’s system prompt. When memory_search and memory_get tools are available, the agent is instructed to search memory files before answering anything about prior work, decisions, dates, people, preferences, or todos:\nBefore answering anything about prior work, decisions, dates, people,\npreferences, or todos: run memory_search on MEMORY.md + memory/*.md;\nthen use memory_get to pull only the needed lines.\nIf low confidence after search, say you checked.\nmemory_search performs semantic search across MEMORY.md and memory/*.md files. Under the hood, it uses qmd — an on-device search engine that combines BM25 full-text search, vector semantic search, and LLM re-ranking. All processing happens locally with GGUF models, no cloud dependency.\nmemory_get is a simple snippet reader. After memory_search returns matching results with file paths and line numbers, memory_get pulls the specific lines needed — keeping the context small and precise.\n\n\n\nWhen a conversation grows long enough to approach the context window limit, OpenClaw triggers a memory flush before compaction happens. The implementation in memory-flush.ts checks whether totalTokens &gt;= contextWindow - reserveTokens - softThreshold (with a default soft threshold of 4000 tokens). When that condition is met, the agent receives a prompt:\nPre-compaction memory flush.\nStore durable memories now (use memory/YYYY-MM-DD.md; create memory/ if needed).\nIf nothing to store, reply with NO_REPLY.\nThis is the intelligent part — the agent analyzes the conversation and decides what’s worth keeping. It’s not a blind dump; the agent extracts decisions, preferences, important context, and writes structured notes to date-stamped markdown files.\n\n\n\nThe session memory hook fires when the user issues the /new command to start a fresh session. Unlike the memory flush, this is deliberately simple:\n\nExtract the last N messages from the previous session (default: 15)\nUse an LLM to generate a short filename slug (e.g., “vendor-pitch”, “api-design”)\nSave the transcript to memory/YYYY-MM-DD-slug.md\n\nNo analysis, no summarization — just a raw transcript dump. The idea is that the raw conversation itself is valuable context for future sessions, and the semantic search on the recall side will find the relevant parts when needed."
  },
  {
    "objectID": "202602/bringing-memory-to-claude-code.html#mapping-to-claude-code",
    "href": "202602/bringing-memory-to-claude-code.html#mapping-to-claude-code",
    "title": "Bringing Memory to Claude Code: Lessons from OpenClaw",
    "section": "",
    "text": "With a clear picture of OpenClaw’s design, the next question is: can we replicate this in Claude Code? The answer is yes, using Claude Code’s hook system.\nClaude Code hooks are shell commands that execute automatically at specific points in a session’s lifecycle. The two events we need are PreCompact (fires before context compaction) and SessionEnd (fires when a session terminates). Both accept command hooks — shell scripts that receive JSON context via stdin.\n\n\nHere’s how OpenClaw’s three-part memory maps to Claude Code:\n\n\n\n\n\n\n\n\nOpenClaw\nClaude Code\nMechanism\n\n\n\n\nMemory Flush (pre-compaction)\nPreCompact hook\nShell script, uses claude -p for extraction\n\n\nSession Memory (/new command)\nSessionEnd hook\nShell script, uses claude -p for slug generation\n\n\nMemory Recall (memory_search)\nqmd MCP server\nMCP integration\n\n\n\nStorage: Memory files are stored at ~/.cc-memory/[project-path]/memory/, where [project-path] is the project’s absolute path converted to a valid folder name (e.g., /Users/me/my-project becomes Users__me__my-project). This keeps memories separated per project while stored in a global location.\nThe choice of PreCompact for memory flush is a direct parallel — both fire right before context compaction. SessionEnd replaces OpenClaw’s /new hook since Claude Code fires it when a session terminates (user exit, /clear, logout). For recall, qmd already provides an MCP server, so Claude Code can use it directly as an MCP tool.\nBoth scripts use claude -p (Claude Code’s pipe mode) for LLM capabilities. This means no API keys to configure, no SDK dependencies — just the claude CLI that’s already installed."
  },
  {
    "objectID": "202602/bringing-memory-to-claude-code.html#implementation",
    "href": "202602/bringing-memory-to-claude-code.html#implementation",
    "title": "Bringing Memory to Claude Code: Lessons from OpenClaw",
    "section": "",
    "text": "Both hooks are configured in ~/.claude/settings.json to apply globally across all projects:\n{\n  \"hooks\": {\n    \"PreCompact\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"$HOME/.cc-memory/scripts/memory-flush.sh\\\"\",\n            \"timeout\": 120\n          }\n        ]\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"$HOME/.cc-memory/scripts/save-session.sh\\\"\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ]\n  }\n}\n\n\n\nThe memory flush script reads the conversation transcript, pipes it to claude -p for intelligent extraction, and writes the result to a memory file:\n#!/bin/bash\n# memory-flush.sh - PreCompact hook\n\nset -euo pipefail\n\n# Guard against recursive invocation (claude -p triggers hooks too)\nif [ \"${CC_MEMORY_HOOK:-}\" = \"1\" ]; then\n  exit 0\nfi\n\nINPUT=$(cat)\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd')\n\n# Convert project path to folder name (strip leading /, replace / with __)\nPROJECT_FOLDER=$(echo \"$CWD\" | sed 's|^/||' | sed 's|/|__|g')\nMEMORY_DIR=\"$HOME/.cc-memory/$PROJECT_FOLDER/memory\"\nmkdir -p \"$MEMORY_DIR\"\n\nDATE=$(date +%Y-%m-%d)\nFILENAME=\"$MEMORY_DIR/$DATE.md\"\n\nif [ ! -f \"$TRANSCRIPT_PATH\" ]; then\n  exit 0\nfi\n\n# Read the last ~50KB of the transcript to stay within token limits\nTRANSCRIPT_CONTENT=$(tail -c 50000 \"$TRANSCRIPT_PATH\")\n\nMEMORY_CONTENT=$(echo \"$TRANSCRIPT_CONTENT\" | CC_MEMORY_HOOK=1 claude -p \\\n  \"You are a memory extraction agent. The following is a conversation\ntranscript (JSONL format) from a coding session. Extract durable memories\nthat should be preserved:\n\n- Decisions made\n- User preferences discovered\n- Important technical context\n- Todos and action items\n- Key outcomes and conclusions\n\nFormat the output as markdown with clear sections and bullet points.\nBe concise but capture everything important.\nIf there is nothing worth saving, respond with exactly NO_REPLY.\")\n\nif [ -z \"$MEMORY_CONTENT\" ] || [ \"$MEMORY_CONTENT\" = \"NO_REPLY\" ]; then\n  exit 0\nfi\n\n# Append separator if file already exists\nif [ -f \"$FILENAME\" ]; then\n  echo \"\" &gt;&gt; \"$FILENAME\"\n  echo \"---\" &gt;&gt; \"$FILENAME\"\n  echo \"\" &gt;&gt; \"$FILENAME\"\nfi\n\necho \"## Memory Flush - $(date -u '+%H:%M UTC')\" &gt;&gt; \"$FILENAME\"\necho \"\" &gt;&gt; \"$FILENAME\"\necho \"$MEMORY_CONTENT\" &gt;&gt; \"$FILENAME\"\n\nexit 0\nA few things to note: - The CC_MEMORY_HOOK=1 prefix sets an environment variable for the claude -p subprocess. Both scripts check this variable at entry and exit early if set — this prevents recursive invocation, since claude -p itself triggers SessionEnd hooks when it finishes. - It reads the last 50KB of the transcript rather than the whole file, to keep the input manageable. - Multiple compactions in the same day append to the same file with --- separators.\n\n\n\nThe session save script dumps the last 15 transcript entries to a file, using claude -p to generate a descriptive filename slug — matching OpenClaw’s approach:\n#!/bin/bash\n# save-session.sh - SessionEnd hook\n\nset -euo pipefail\n\n# Guard against recursive invocation (claude -p triggers hooks too)\nif [ \"${CC_MEMORY_HOOK:-}\" = \"1\" ]; then\n  exit 0\nfi\n\nINPUT=$(cat)\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd')\n\n# Convert project path to folder name (strip leading /, replace / with __)\nPROJECT_FOLDER=$(echo \"$CWD\" | sed 's|^/||' | sed 's|/|__|g')\nMEMORY_DIR=\"$HOME/.cc-memory/$PROJECT_FOLDER/memory\"\nmkdir -p \"$MEMORY_DIR\"\n\nDATE=$(date +%Y-%m-%d)\n\nif [ ! -f \"$TRANSCRIPT_PATH\" ]; then\n  exit 0\nfi\n\n# Extract last 15 entries from transcript JSONL\nSESSION_CONTENT=$(tail -n 15 \"$TRANSCRIPT_PATH\")\n\n# Generate slug via claude -p (first 2000 chars to keep it fast)\nSLUG=$(echo \"$SESSION_CONTENT\" | head -c 2000 | CC_MEMORY_HOOK=1 claude -p \\\n  \"Based on this conversation transcript, generate a short 1-2 word\nfilename slug (lowercase, hyphen-separated, no file extension).\nReply with ONLY the slug, nothing else.\nExamples: vendor-pitch, api-design, bug-fix\")\n\n# Sanitize slug: lowercase, only alphanumeric and hyphens, max 30 chars\nSLUG=$(echo \"$SLUG\" | tr '[:upper:]' '[:lower:]' \\\n  | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' \\\n  | sed 's/^-//' | sed 's/-$//' | head -c 30)\n\n# Fallback to timestamp if slug generation fails\nif [ -z \"$SLUG\" ]; then\n  SLUG=$(date +%H%M)\nfi\n\nFILENAME=\"$MEMORY_DIR/$DATE-$SLUG.md\"\n\necho \"# Session: $(date -u '+%Y-%m-%d %H:%M:%S UTC')\" &gt; \"$FILENAME\"\necho \"- **Project**: $CWD\" &gt;&gt; \"$FILENAME\"\necho \"\" &gt;&gt; \"$FILENAME\"\necho \"$SESSION_CONTENT\" &gt;&gt; \"$FILENAME\"\n\nexit 0\nThe only LLM usage here is for the filename slug — the transcript content itself is saved as-is. The semantic search on the recall side handles finding relevant content later.\n\n\n\nFor the recall side, qmd provides an MCP server out of the box. The setup involves:\n\nCreate a collection for each project’s memory directory:\n\nqmd collection create my-project ~/.cc-memory/my_project/memory \\\n  --context \"Development memories and session history for my-project\"\n\nConfigure Claude Code to use qmd as an MCP server. In .claude/settings.json or ~/.claude/settings.json:\n\n{\n  \"mcpServers\": {\n    \"qmd\": {\n      \"command\": \"qmd\",\n      \"args\": [\"mcp\"]\n    }\n  }\n}\n\nGuide recall behavior via CLAUDE.md. Add instructions similar to OpenClaw’s system prompt:\n\n## Memory\n\nBefore answering questions about prior work, decisions, or preferences,\nsearch the memory collection using the qmd MCP tools. Use the search\nresults to inform your response.\nOnce configured, Claude Code can use qmd’s MCP tools — semantic search, deep search with reranking, and document retrieval — to query the memory files. This completes the memory lifecycle: PreCompact and SessionEnd write memories, qmd reads them back."
  },
  {
    "objectID": "202602/bringing-memory-to-claude-code.html#conclusion",
    "href": "202602/bringing-memory-to-claude-code.html#conclusion",
    "title": "Bringing Memory to Claude Code: Lessons from OpenClaw",
    "section": "",
    "text": "Studying OpenClaw’s memory system was a rewarding exercise. The three-part design — recall, flush, and session save — is elegant in how each part has a clear responsibility and minimal complexity. The memory flush is smart (LLM-driven analysis), the session save is dumb (raw transcript dump with an LLM-generated slug), and the recall leverages semantic search to find needles in haystacks.\nThe mapping to Claude Code turned out to be straightforward. PreCompact and SessionEnd fire at exactly the right moments, claude -p gives hook scripts access to LLM capabilities without any extra setup, and qmd — the same tool OpenClaw uses internally for memory_search — provides the recall side via MCP.\nWhat I took away from this is that Claude Code’s hook system, combined with MCP, makes it surprisingly extensible. These hooks weren’t designed for memory, but they provide the right building blocks. If you’re interested in extending Claude Code beyond its defaults, the hook system is worth a look."
  }
]